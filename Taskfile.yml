version: "3"

dotenv: [".env"]
vars:
  VENV: ".venv"
  PYTHON: "python3"

tasks:

  _check_venv:
    internal: true
    silent: true
    cmds:
      - |
        if [ ! -d "{{.VENV}}" ]; then
          echo ".venv not found. Run: make env"
          exit 1
        fi

  lint:
    desc: "Run black, isort, and flake8"
    deps: [_check_venv]
    cmds:
      - '{{.VENV}}/bin/black src tests'
      - '{{.VENV}}/bin/isort src tests'
      - '{{.VENV}}/bin/flake8 src tests'
      - '{{.VENV}}/bin/pylint src tests'

  lint:check:
    desc: "Validate formatting (no changes)"
    deps: [_check_venv]
    cmds:
      - '{{.VENV}}/bin/black --check src tests'
      - '{{.VENV}}/bin/isort --check-only src tests'
      - '{{.VENV}}/bin/flake8 src tests'
      - '{{.VENV}}/bin/pylint src tests  || true'

  tests:
    deps: [_check_venv]
    cmds:
      - '{{.VENV}}/bin/pytest -q'

  check:clean:
    internal: true
    silent: true
    desc: "Fail if working tree is not clean"
    cmds:
      - |
        echo "==> Checking working tree..."
        if ! git diff --quiet || ! git diff --cached --quiet; then
          echo "Working tree not clean. Commit or stash first."
          exit 1
        fi

  check:not-ci:
    cmds:
      - |
        if [ "${CI:-}" != "" ]; then
          echo "ERROR: This task must not run in CI."
          exit 1
        fi

  # ============================================================
  # Feature Branch Workflow (Developers)
  # ============================================================

  feature:start:
    desc: "Sync main and create a new feature branch"
    deps: [check:not-ci, check:clean]
    cmds:
      - |
        if [ -z "{{.CLI_ARGS}}" ]; then
          echo "Usage: task feature:start <branch-name>"
          exit 1
        fi

        BRANCH="{{.CLI_ARGS}}"

        # Auto-prefix "feature/" if missing
        if ! echo "$BRANCH" | grep -Eq '^feature/'; then
          BRANCH="feature/$BRANCH"
        fi

        echo "==> Updating main"
        git checkout main
        git pull --rebase

        echo "==> Creating branch '$BRANCH'"
        git checkout -b "$BRANCH"

        echo "Branch '$BRANCH' created and ready."

  commit:
    desc: "Lint Check, test, update CHANGELOG, and commit staged changes (Conventional Commit format)"
    vars:
      MSG:
        sh: 'echo ${MSG:-}'
    cmds:

      # 1) Ensure message is provided
      - |
        if [ -z "{{.MSG}}" ]; then
          echo "Usage: task commit MSG='feat: add MPC diagnostics'"
          exit 1
        fi

      # 2) Enforce Conventional Commits
      - |
        if ! echo "{{.MSG}}" | grep -Eq '^(feat|fix|docs|style|refactor|perf|test|chore)(\([a-zA-Z0-9_-]+\))?: .+'; then
          echo "ERROR: Commit message must follow Conventional Commits."
          echo ""
          echo "Allowed types:"
          echo "  feat, fix, docs, style, refactor, perf, test, chore"
          echo ""
          echo "Example formats:"
          echo "  feat: add new capability"
          echo "  feat(scope): introduce feature in <scope>"
          echo "  fix: correct incorrect behavior"
          echo "  fix(scope): resolve issue in <scope>"
          echo "  docs: update documentation"
          echo "  docs(scope): modify docs in <scope>"
          echo "  style: reformat code (no logic change)"
          echo "  style(scope): adjust formatting in <scope>"
          echo "  refactor: improve code structure (same behavior)"
          echo "  refactor(scope): reorganize code in <scope>"
          echo "  perf: improve performance"
          echo "  perf(scope): optimize behavior in <scope>"
          echo "  test: update or add tests"
          echo "  test(scope): modify tests in <scope>"
          echo "  chore: update build or tooling"
          echo "  chore(scope): modify CI/scripts/config"
          echo ""
          echo "Usage: task commit MSG='feat: add <something>'"
          exit 1
        fi

      # 3) Do NOT allow committing on main
      - |
        BRANCH="$(git rev-parse --abbrev-ref HEAD)"
        if [ "$BRANCH" = "main" ] || [ "$BRANCH" = "master" ]; then
          echo "ERROR: You are on '$BRANCH'. Commit only on feature branches."
          exit 1
        fi
        echo "==> Current branch: $BRANCH"

      # 4) Ensure something is staged (no git add . here)
      - |
        if git diff --cached --quiet; then
          echo "ERROR: No staged files detected."
          echo "Stage files manually using:"
          echo "  git add <file1> <file2> ..."
          exit 1
        fi
        echo "==> Staged files detected"

      # 7) Run tests
      - task tests

      # 6) Lint (flake8)
      - task lint:check

      # 8) Update CHANGELOG under [Unreleased]
      - |
        echo "==> Updating CHANGELOG.md"
        if [ ! -f CHANGELOG.md ]; then
          echo "# Changelog" > CHANGELOG.md
          echo >> CHANGELOG.md
          echo "## [Unreleased]" >> CHANGELOG.md
          echo >> CHANGELOG.md
        fi

        # Ensure [Unreleased] section exists in existing changelog
        if ! grep -q '^## \[Unreleased\]' CHANGELOG.md; then
          echo "ERROR: '## [Unreleased]' section missing in CHANGELOG.md."
          echo "Add it back manually before committing."
          exit 1
        fi

        DATE="$(date +%Y-%m-%d)"
        awk -v msg="- ${DATE}: {{.MSG}}" '
          /^## \[Unreleased\]/ && !seen++ { print; print ""; print msg; next }
          { print }
        ' CHANGELOG.md > CHANGELOG.tmp && mv CHANGELOG.tmp CHANGELOG.md

        git add CHANGELOG.md

      # 9) Commit ONLY staged changes
      - |
        echo "==> Committing staged changes"
        git commit -m "{{.MSG}}"
        echo
        echo "Committed on '$BRANCH' with message:"
        echo "  {{.MSG}}"

  feature:push:
    desc: "Run tests, rebase current branch on main, then push"
    deps: [check:not-ci, check:clean]
    cmds:
      - |
        BRANCH="$(git rev-parse --abbrev-ref HEAD)"
        if [ "$BRANCH" = "main" ] || [ "$BRANCH" = "master" ]; then
          echo "ERROR: You are on $BRANCH. Switch to a feature branch."
          exit 1
        fi

        echo "==> Using feature branch: $BRANCH"

        echo "==> Running tests (pre-rebase)"
        task tests

        echo "==> Updating main"
        git checkout main
        git pull --rebase

        echo "==> Rebasing $BRANCH onto main"
        git checkout "$BRANCH"
        git rebase main

        echo "==> Running tests (post-rebase)"
        task tests

        echo "==> Pushing branch $BRANCH"
        git push --force-with-lease -u origin "$BRANCH"

        echo "Feature branch '$BRANCH' pushed and ready for MR."

  # ============================================================
  # Docs
  # ============================================================

  docs:api:
    desc: "Generate API docs with sphinx-apidoc"
    vars:
      SOURCEDIR: docs/source
      # Each entry is a path given to sphinx-apidoc
      API_PACKAGES: "src"
    cmds:
      - |
        for pkg in {{.API_PACKAGES}}; do
          outdir="{{.SOURCEDIR}}/api/$pkg"
          mkdir -p "$outdir"
          .venv/bin/sphinx-apidoc -e -M -f \
            -t "{{.SOURCEDIR}}/_templates" \
            -o "$outdir" \
            "$pkg"
        done

  docs:build:
    desc: "Build Sphinx docs"
    deps: [docs:api]
    cmds:
      - |
        if ! command -v sphinx-build >/dev/null; then
          echo "sphinx-build not found. Install docs dependencies."
          exit 1
        fi
      - .venv/bin/sphinx-build -M html docs/source docs/_build/html

  docs:serve:
    desc: "Serve built documentation"
    deps: [docs:build]
    cmds:
      - |
        if [ ! -d docs/_build/html ]; then
          echo "Docs not built. Run: task docs:build"
          exit 1
        fi
      - echo "Serving docs at http://localhost:8000"
      - cd docs/_build/html && python3 -m http.server 8000

  # ============================================================
  # Environment & Dev Utilities
  # ============================================================
  dev:env-create:
    desc: "Create virtualenv"
    cmds:
      - '{{.PYTHON}} -m venv {{.VENV}}'
      - '{{.VENV}}/bin/pip install -U pip'

  dev:env-export:
    desc: "Export environment for developer to requirements-lock.txt"
    deps: [_check_venv]
    cmds:
      - '{{.VENV}}/bin/pip freeze > requirements-lock.txt'
      - echo "Exported to requirements-lock.txt"

  dev:env-install:
    desc: "Install project with all dev & docs tools"
    deps: [dev:env-create, _check_venv]
    cmds:
      - '{{.VENV}}/bin/pip install -e ".[dev,docs]"'

  release:cut:
    desc: "Full release: bump VERSION + pyproject.toml, rotate CHANGELOG, tag, push"
    deps: [check:not-ci, check:clean]
    vars:
      NEW_VERSION:
        sh: 'echo ${VER:-}'
    cmds:
      # 0) Ensure version was provided
      - |
        if [ -z "{{.NEW_VERSION}}" ]; then
          echo "Usage: VER=1.2.0 task release:cut"
          exit 1
        fi

      # # 1) Ensure we are on main
      - |
        BRANCH="$(git rev-parse --abbrev-ref HEAD)"
        if [ "$BRANCH" != "main" ]; then
          echo "ERROR: release:cut must be run on main, currently on '$BRANCH'"
          exit 1
        fi

      # 2) Update local main
      - git pull --rebase

      # 3) Update VERSION file
      - echo "{{.NEW_VERSION}}" > VERSION

      # 4) Update pyproject.toml [project].version
      - |
        python - << 'PY'
        from pathlib import Path

        new_version = "{{.NEW_VERSION}}"

        py = Path("pyproject.toml")
        text = py.read_text()

        out_lines = []
        in_project = False
        for line in text.splitlines():
            if line.strip().startswith("[project]"):
                in_project = True
                out_lines.append(line)
                continue
            if in_project and line.strip().startswith("version"):
                out_lines.append(f'version = "{new_version}"')
                in_project = False
                continue
            out_lines.append(line)

        py.write_text("\n".join(out_lines) + "\n")
        PY

      # 5) Rotate CHANGELOG: move [Unreleased] entries into new [X.Y.Z - YYYY-MM-DD]
      - |
        python - << 'PY'
        from pathlib import Path
        import datetime
        import re

        new_version = "{{.NEW_VERSION}}"
        today = datetime.date.today().isoformat()

        ch_path = Path("CHANGELOG.md")
        if not ch_path.exists():
            raise SystemExit("CHANGELOG.md not found")

        text = ch_path.read_text()

        # Match: [Unreleased] header + its body + the next heading (or end)
        # Groups: 1 = "## [Unreleased]...", 2 = body, 3 = rest (from next heading on)
        m = re.search(
            r"(## \\[Unreleased\\]\\s*)(.*?)(\\n## \\[.*|\\Z)",
            text,
            flags=re.S,
        )
        if not m:
            raise SystemExit("Could not find '[Unreleased]' section to rotate")

        unreleased_header, body, rest = m.groups()
        body = body.strip()
        if not body:
            raise SystemExit("Unreleased section is empty; nothing to release")

        before = text[: m.start()]

        new_unreleased = "## [Unreleased]\\n\\n"
        new_section = f"## [{new_version}] - {today}\\n\n{body}\\n\\n"

        new_text = before + new_unreleased + new_section + (rest.lstrip("\\n") if rest else "")

        ch_path.write_text(new_text)
        PY

      # 6) Commit VERSION + pyproject.toml + CHANGELOG
      - git add VERSION pyproject.toml CHANGELOG.md

      - "git commit -m 'chore: release v{{.NEW_VERSION}}'"

      # 7) Tag and push
      - git tag -a "v{{.NEW_VERSION}}" -m "Release v{{.NEW_VERSION}}"
      - git push
      - git push origin "v{{.NEW_VERSION}}"
