version: "3"

dotenv: [".env"]
vars:
  VENV: ".venv"
  PYTHON: "python3"

tasks:

  _check_venv:
    internal: true
    silent: true
    cmds:
      - |
        if [ ! -d "{{.VENV}}" ]; then
          echo ".venv not found. Run: make env"
          exit 1
        fi

  lint:
    desc: "Run black, isort, and flake8"
    deps: [_check_venv]
    cmds:
      - '{{.VENV}}/bin/black src tests'
      - '{{.VENV}}/bin/isort src tests'
      - '{{.VENV}}/bin/flake8 src tests'
      - '{{.VENV}}/bin/pylint src tests'

  lint-check:
    desc: "Validate formatting (no changes)"
    deps: [_check_venv]
    cmds:
      - '{{.VENV}}/bin/black --check src tests'
      - '{{.VENV}}/bin/isort --check-only src tests'
      - '{{.VENV}}/bin/flake8 src tests'
      - '{{.VENV}}/bin/pylint src tests  || true'
      - '{{.VENV}}/bin/mypy src tests || true'

  tests:
    deps: [_check_venv]
    cmds:
      - '{{.VENV}}/bin/pytest -q'

  check_clean:
    internal: true
    silent: true
    desc: "Fail if working tree is not clean"
    cmds:
      - |
        echo "==> Checking working tree..."
        if ! git diff --quiet || ! git diff --cached --quiet; then
          echo "Working tree not clean. Commit or stash first."
          exit 1
        fi

  check_not-ci:
    cmds:
      - |
        if [ "${CI:-}" != "" ]; then
          echo "ERROR: This task must not run in CI."
          exit 1
        fi

  # ============================================================
  # Feature Branch Workflow (Developers)
  # ============================================================

  feature-start:
    desc: "Sync main and create a new feature branch"
    deps: [check_not-ci, check_clean]
    cmds:
      - |
        if [ -z "{{.CLI_ARGS}}" ]; then
          echo "Usage: task feature-start <branch-name>"
          exit 1
        fi

        BRANCH="{{.CLI_ARGS}}"

        # Auto-prefix "feature/" if missing
        if ! echo "$BRANCH" | grep -Eq '^feature/'; then
          BRANCH="feature/$BRANCH"
        fi

        echo "==> Updating main"
        git checkout main
        git pull --rebase

        echo "==> Creating branch '$BRANCH'"
        git checkout -b "$BRANCH"

        echo "Branch '$BRANCH' created and ready."

  commit:
    desc: "Lint Check, test, update CHANGELOG, and commit staged changes (Conventional Commit format)"
    vars:
      MSG: { sh: 'echo "${MSG:-}"' }
    cmds:
      - |-
        # === Update CHANGELOG under [Unreleased] ===

        if [ -z "{{.MSG}}" ]; then
          echo "ERROR: MSG is empty, cannot update CHANGELOG."
          exit 1
        fi

        MSG="{{.MSG}}"
        TYPE=$(printf '%s\n' "$MSG" | cut -d':' -f1)
        DESC=$(printf '%s\n' "$MSG" | cut -d':' -f2- | sed 's/^ *//')
        DATE=$(date +%Y-%m-%d)

        # Ensure CHANGELOG exists with structure
        if [ ! -f CHANGELOG.md ]; then
        cat > CHANGELOG.md <<'EOF'
        # Changelog

        ## [Unreleased]

        ### Added
        ### Changed
        ### Fixed

        EOF
        fi

        if ! grep -q '^## \[Unreleased\]' CHANGELOG.md; then
          echo "ERROR: '## [Unreleased]' section missing."
          exit 1
        fi

        # Map type → section
        case "$TYPE" in
          feat) SECTION="### Added" ;;
          fix) SECTION="### Fixed" ;;
          chore) SECTION="### Changed" ;;
          *) SECTION="### Changed" ;;
        esac

        # Insert bullet under correct section
        awk -v section="$SECTION" -v line="- ${DATE}: ${TYPE}: ${DESC}" '
          BEGIN { in_unrel=0; inserted=0 }
          /^## \[Unreleased\]/ { in_unrel=1 }
          /^## \[/ && $0 !~ /\[Unreleased\]/ { in_unrel=0 }
          {
            print
            if (in_unrel && $0 == section && !inserted) {
              print ""
              print line
              inserted=1
            }
          }
        ' CHANGELOG.md > CHANGELOG.tmp && mv CHANGELOG.tmp CHANGELOG.md

        git add CHANGELOG.md || true

      # 7) Commit ONLY staged changes
      - |
        echo "==> Committing staged changes"
        git commit -m "{{.MSG}}"
        echo
        echo "Committed on '$BRANCH' with message:"
        echo "  {{.MSG}}"

  feature-push:
    desc: "Run tests, rebase current branch on main, then push"
    deps: [check_not-ci, check_clean]
    cmds:
      - |
        BRANCH="$(git rev-parse --abbrev-ref HEAD)"
        if [ "$BRANCH" = "main" ] || [ "$BRANCH" = "master" ]; then
          echo "ERROR: You are on $BRANCH. Switch to a feature branch."
          exit 1
        fi

        echo "==> Using feature branch: $BRANCH"

        echo "==> Running tests (pre-rebase)"
        task tests

        echo "==> Updating main"
        git checkout main
        git pull --rebase

        echo "==> Rebasing $BRANCH onto main"
        git checkout "$BRANCH"
        git rebase main

        echo "==> Running tests (post-rebase)"
        task tests

        echo "==> Pushing branch $BRANCH"
        git push --force-with-lease -u origin "$BRANCH"

        echo "Feature branch '$BRANCH' pushed and ready for MR."

  # ============================================================
  # Docs
  # ============================================================

  docs-clean:
    desc: "Clean built docs"
    cmds:
      - rm -rf docs/_build/*
      - rm -rf docs/source/api/*

  docs-api:
    desc: "Generate API docs with sphinx-apidoc"
    deps: [docs-clean]
    vars:
      SOURCEDIR: docs/source
      # Each entry is a path given to sphinx-apidoc
      API_PACKAGES: "src"
    cmds:
      - |
        for pkg in {{.API_PACKAGES}}; do
          outdir="{{.SOURCEDIR}}/api/$pkg"
          mkdir -p "$outdir"
          .venv/bin/sphinx-apidoc -e -M -f \
            -t "{{.SOURCEDIR}}/_templates" \
            -o "$outdir" \
            "$pkg"
        done

  docs-build:
    desc: "Build Sphinx docs"
    deps: [docs-api]
    cmds:
      - |
        if ! command -v sphinx-build >/dev/null; then
          echo "sphinx-build not found. Install docs dependencies."
          exit 1
        fi
      - .venv/bin/sphinx-build -b html docs/source docs/_build/html

  docs-serve:
    desc: "Serve built documentation"
    deps: [docs-build]
    cmds:
      - |
        if [ ! -d docs/_build/html ]; then
          echo "Docs not built. Run: task docs-build"
          exit 1
        fi
      - echo "Serving docs at http://localhost:8000"
      - cd docs/_build/html && python3 -m http.server 8000

  # ============================================================
  # Environment & Dev Utilities
  # ============================================================
  dev-env-create:
    desc: "Create virtualenv"
    cmds:
      - '{{.PYTHON}} -m venv {{.VENV}}'
      - '{{.VENV}}/bin/pip install -U pip'

  dev-env-export:
    desc: "Export environment for developer to requirements-lock.txt"
    deps: [_check_venv]
    cmds:
      - '{{.VENV}}/bin/pip freeze > requirements-lock.txt'
      - echo "Exported to requirements-lock.txt"

  dev-env-install:
    desc: "Install project with all dev & docs tools"
    deps: [dev-env-create, _check_venv]
    cmds:
      - '{{.VENV}}/bin/pip install -e ".[dev,docs]"'
      - '{{.VENV}}/bin/pre-commit install'

  release-cut:
    desc: "Full release: bump VERSION + pyproject.toml, rotate CHANGELOG, tag, push"
    deps: [check_not-ci, check_clean]
    vars:
      NEW_VERSION:
        sh: 'echo ${VER:-}'
    cmds:
      # 0) Ensure version was provided
      - |
        if [ -z "{{.NEW_VERSION}}" ]; then
          echo "Usage: VER=1.2.0 task release-cut"
          exit 1
        fi

      # # 1) Ensure we are on main
      - |
        BRANCH="$(git rev-parse --abbrev-ref HEAD)"
        if [ "$BRANCH" != "main" ]; then
          echo "ERROR: release-cut must be run on main, currently on '$BRANCH'"
          exit 1
        fi

      # 2) Update local main
      - git pull --rebase

      # 3) Update VERSION file
      - echo "{{.NEW_VERSION}}" > VERSION

      # 4) Update pyproject.toml [project].version
      - |
        python - << 'PY'
        from pathlib import Path

        new_version = "{{.NEW_VERSION}}"

        py = Path("pyproject.toml")
        text = py.read_text()

        out_lines = []
        in_project = False
        for line in text.splitlines():
            if line.strip().startswith("[project]"):
                in_project = True
                out_lines.append(line)
                continue
            if in_project and line.strip().startswith("version"):
                out_lines.append(f'version = "{new_version}"')
                in_project = False
                continue
            out_lines.append(line)

        py.write_text("\n".join(out_lines) + "\n")
        PY

      # 5) Rotate CHANGELOG: move [Unreleased] entries into new [X.Y.Z - YYYY-MM-DD]
      - |
        python - << 'PY'
        from pathlib import Path
        import datetime
        import re

        new_version = "{{.NEW_VERSION}}"
        today = datetime.date.today().isoformat()

        ch_path = Path("CHANGELOG.md")
        if not ch_path.exists():
            raise SystemExit("CHANGELOG.md not found")

        text = ch_path.read_text()

        # Match: [Unreleased] header + its body + the next heading (or end)
        # Groups: 1 = "## [Unreleased]...", 2 = body, 3 = rest (from next heading on)
        m = re.search(
            r"(## \\[Unreleased\\]\\s*)(.*?)(\\n## \\[.*|\\Z)",
            text,
            flags=re.S,
        )
        if not m:
            raise SystemExit("Could not find '[Unreleased]' section to rotate")

        unreleased_header, body, rest = m.groups()
        body = body.strip()
        if not body:
            raise SystemExit("Unreleased section is empty; nothing to release")

        before = text[: m.start()]

        new_unreleased = "## [Unreleased]\\n\\n"
        new_section = f"## [{new_version}] - {today}\\n\n{body}\\n\\n"

        new_text = before + new_unreleased + new_section + (rest.lstrip("\\n") if rest else "")

        ch_path.write_text(new_text)
        PY

      # 6) Commit VERSION + pyproject.toml + CHANGELOG
      - git add VERSION pyproject.toml CHANGELOG.md

      - "git commit -m 'chore: release v{{.NEW_VERSION}}'"

      # 7) Tag and push
      - git tag -a "v{{.NEW_VERSION}}" -m "Release v{{.NEW_VERSION}}"
      - git push
      - git push origin "v{{.NEW_VERSION}}"

  clean:
    desc: "Clean cache and build artifacts (keeps the virtual env)"
    cmds:
      - echo ">>> Cleaning Python caches, test cache, mypy cache, build artifacts, benchmarks"

      # pytest
      - rm -rf .pytest_cache

      # mypy
      - rm -rf .mypy_cache

      # coverage
      - rm -f .coverage
      - rm -rf htmlcov

      # benchmarks (pytest-benchmark)
      - rm -rf .benchmarks

      # build artifacts
      - rm -rf dist build
      - rm -rf *.egg-info

      # Python bytecode caches
      - find . -type d -name "__pycache__" -exec rm -rf {} +

      # Jupyter notebook junk
      - find . -type d -name ".ipynb_checkpoints" -exec rm -rf {} +

      # virtual documents (Jupyter)
      - rm -rf .virtual_documents

      # Sphinx build (optional — remove if you want to keep docs cache)
      - rm -rf docs/_build

      # pre-commit cache (optional)
      - rm -rf ~/.cache/pre-commit
